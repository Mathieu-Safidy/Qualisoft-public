name: Qualisoft Backend Deployment
run-name: Runned by ${{ gitea.actor }} ðŸš€
on:
  release:
    types: [published]

env:
  APP_NAME: qualisoft
  REGISTRY_HOST: ${{ secrets.REGISTRY_HOST }}
  REMOTE_K8S_MANIFESTS_DIR: ${{ secrets.REMOTE_K8S_MANIFESTS_DIR }}/${{ env.APP_NAME }} # Directory on the control plane
  K8S_CONTROL_PLANE: ${{ secrets.K8S_CONTROL_PLANE }} # Your Kubernetes control plane IP
  PROCESSED_K8S_DIR: _k8s_processed # Temporary directory for processed manifests on runner
  IMAGE_NAME: ${{ env.APP_NAME }}
  APP_ROUTE: ${{ env.APP_NAME }}
  K8S_MANIFESTS_FOLDER: k8s # The folder containing your manifest templates
  NAMESPACE: luminess-webapp
  SERVICE_PORT: 80
  CONTAINER_PORT: 80
jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4 # Uses a standard GitHub Action to get your code
      # - name: Set up Docker BuildX
      #   uses: docker/setup-buildx-action@v1
      # - name: Check variables
      #   run: |
      #     echo ${{ secrets.REGISTRY_USERNAME }}
      #     echo ${{ secrets.REGISTRY_PASSWORD }}
      - name: Login to Docker Registry
        # If your local registry requires authentication, uncomment and configure this step
        uses: docker/login-action@v1
        with:
          registry: ${{ env.REGISTRY_HOST }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: ./projet
          file: ./projet/Dockerfile
          #target: dind
          platforms: |
            linux/amd64
          push: true
          network: host
          tags: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME}}
  deploy:
    runs-on: ubuntu-22.04
    needs: build # This job depends on 'build'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4 # Uses a standard GitHub Action to get your code
      - name: Process Kubernetes Manifests
        run: |
          mkdir -p ${{ env.PROCESSED_K8S_DIR }}
          for file in ${{ env.K8S_MANIFESTS_FOLDER }}/*.yaml; do
            filename=$(basename "$file")
            sed -e "s|{{REGISTRY_HOST}}|${{ env.REGISTRY_HOST }}|g" \
                -e "s|{{APP_NAME}}|${{ env.APP_NAME }}|g" \
                -e "s|{{APP_ROUTE}}|${{ env.APP_ROUTE }}|g" \
                -e "s|{{NAMESPACE}}|${{ env.NAMESPACE }}|g" \
                -e "s|{{SERVICE_PORT}}|${{ env.SERVICE_PORT }}|g" \
                -e "s|{{CONTAINER_PORT}}|${{ env.CONTAINER_PORT }}|g" \
                "$file" > "${{ env.PROCESSED_K8S_DIR }}/$filename"
            echo "Processed $filename"
          done
      - name: Copy Processed Kubernetes Manifests to Control Plane via SSH
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.K8S_CONTROL_PLANE }}
          username: ${{ secrets.SSH_USER }}
          # key: ${{ secrets.SSH_KEY }}
          password: ${{ secrets.SSH_PASSWORD }}
          strip_components: 1
          source: "${{ env.PROCESSED_K8S_DIR }}/*" # Copy all processed files
          target: ${{ env.REMOTE_K8S_MANIFESTS_DIR }}
          overwrite: true # Overwrite existing files
      - name: Organize the manifests
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.K8S_CONTROL_PLANE }}
          username: ${{ secrets.SSH_USER }}
          # key: ${{ secrets.SSH_KEY }}
          password: ${{ secrets.SSH_PASSWORD }}
          script: |
            mkdir -p ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace-and-secrets
            mkdir -p ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/monitoring
            kubectl get secret regcred --namespace default -o yaml > ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace-and-secrets/regcred.yaml    # Get the default secret in the namespace for pulling
            sed -i "s|default|${{ env.NAMESPACE }}|g" ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace-and-secrets/regcred.yaml   # Modify the namespace in the file to not be default
            mv ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace.yaml ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace-and-secrets/namespace.yaml
            find ${{ env.REMOTE_K8S_MANIFESTS_DIR }} -type f -name "*-secret.yaml" -exec mv {} ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace-and-secrets/ \;
            find ${{ env.REMOTE_K8S_MANIFESTS_DIR }} -type f -name "*-monitor.yaml" -exec mv {} ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/monitoring/ \;  # Move monitoring related files to monitoring
      - name: Delete currently applied manifests
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.K8S_CONTROL_PLANE }}
          username: ${{ secrets.SSH_USER }}
          # key: ${{ secrets.SSH_KEY }}
          password: ${{ secrets.SSH_PASSWORD }}
          script: |
            kubectl delete -f ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace-and-secrets/regcred.yaml 2> /dev/null || true # Delete secret to avoid override
            kubectl delete -f ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/monitoring/ 2> /dev/null || true # Delete secret to avoid override
            kubectl delete -f ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/ 2> /dev/null || true  # Deploying deployment and services
      - name: Apply Kubernetes Manifests on Control Plane via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.K8S_CONTROL_PLANE }}
          username: ${{ secrets.SSH_USER }}
          # key: ${{ secrets.SSH_KEY }}
          password: ${{ secrets.SSH_PASSWORD }}
          script: |
            kubectl apply -f ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/namespace-and-secrets/
            kubectl apply -f ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/     # Deploying deployment and services
            kubectl apply -f ${{ env.REMOTE_K8S_MANIFESTS_DIR }}/monitoring/ 2> /dev/null || true # Run service monitor last
      - name: Upload K8s manifests artifacts
        uses: actions/upload-artifact@v3
        with:
          name: k8s-artifacts
          path: ${{env.PROCESSED_K8S_DIR}}
          retention-days: 2
  # Job to send success notification
  notify_success:
    # runs-on: ubuntu-22.04
    needs:
      - build # This job depends on 'build'
      - deploy # This job depends on 'deploy'
    if: success() && always() # Run only if 'build' succeeded AND if the 'always()' context is met
    uses: ./.gitea/workflows/notifications.yml # Path to your reusable workflow
    with:
      status: success
      repository: ${{ github.repository }}
      branch: ${{ github.ref }}
      run_id: ${{ github.run_id }}
      actor: ${{ github.actor }}
    secrets:
      EMAIL_NOTIFICATION_TOKEN: ${{ secrets.EMAIL_NOTIFICATION_TOKEN }}
  # Job to send failure notification
  notify_failure:
    # runs-on: ubuntu-22.04
    needs:
      - build # This job depends on 'build'
      - deploy # This job depends on 'build'
    if: failure() && always() # Run only if 'build' failed AND if the 'always()' context is met
    uses: ./.gitea/workflows/notifications.yml
    with:
      status: failure
      repository: ${{ github.repository }}
      branch: ${{ github.ref }}
      run_id: ${{ github.run_id }}
      actor: ${{ github.actor }}
    secrets:
      EMAIL_NOTIFICATION_TOKEN: ${{ secrets.EMAIL_NOTIFICATION_TOKEN }}