name: Qualisoft Backend Deployment (Hybride Push/Pull)
run-name: Runned by ${{ github.actor }} üöÄ 
on:
  release:
    types: [published]

env:
  APP_NAME: qualisoft
  PROCESSED_K8S_DIR: _k8s_processed # Dossier temporaire sur le runner
  K8S_MANIFESTS_FOLDER: k8s         # Dossier contenant vos mod√®les de manifestes
  NAMESPACE: luminess-webapp
  
  # Le tag doit √™tre unique, bas√© sur le SHA ou un ID de Run pour √©viter les probl√®mes de cache
  IMAGE_TAG: ${{ github.sha }} 
  IMAGE_FULL_TAG: ${{ secrets.REGISTRY_HOST }}/${{ secrets.REGISTRY_USERNAME }}/qualisoft:${{ github.sha }} # Chemin complet du registre
  
  # Variables pour le remplacement dans les manifestes
  APP_ROUTE: qualisoft
  SERVICE_PORT: 80
  CONTAINER_PORT: 80

jobs:
  build:
    runs-on: self-hosted
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 1. Login au registre Docker distant (Secrets requis)
      - name: Login to Docker Registry
        uses: docker/login-action@v1
        with:
          registry: ${{ secrets.REGISTRY_HOST }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      # 2. Build et PUSH vers le registre distant (Push: true)
      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          platforms: linux/amd64
          push: true  # ‚¨ÖÔ∏è Changement : Pousse l'image
          tags: ${{ env.IMAGE_FULL_TAG }} # ‚¨ÖÔ∏è Changement : Utilise le tag complet du registre
          network: host

  deploy:
    runs-on: self-hosted
    needs: build
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Ensure Namespace Exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      # 3. CR√âATION DU SECRET K8S : N√©cessaire pour que Minikube puisse pull l'image
      - name: Create or Update Docker Registry Secret (regcred)
        shell: powershell
        run: |
          # Cr√©e ou met √† jour le secret 'regcred' dans Minikube
          kubectl create secret docker-registry regcred `
            --namespace ${{ env.NAMESPACE }} `
            --docker-server="${{ secrets.REGISTRY_HOST }}" `
            --docker-username="${{ secrets.REGISTRY_USERNAME }}" `
            --docker-password="${{ secrets.REGISTRY_PASSWORD }}" `
            --dry-run=client -o yaml | kubectl apply -f -
        env:
          # Les secrets sont pass√©s ici pour l'ex√©cution locale de la commande
          REGISTRY_HOST: ${{ secrets.REGISTRY_HOST }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Process Kubernetes Manifests
        shell: powershell
        run: |
          # Cr√©ation du dossier temporaire
          New-Item -ItemType Directory -Force -Path $env:PROCESSED_K8S_DIR
          
          # Remplacement des placeholders avec powershell natif
          Get-ChildItem $env:K8S_MANIFESTS_FOLDER -Filter *.yaml | ForEach-Object {
              $file = $_.FullName
              $filename = $_.Name

              $content = Get-Content $file -Raw
              $content = $content -replace '{{APP_NAME}}', $env:APP_NAME
              $content = $content -replace '{{NAMESPACE}}', $env:NAMESPACE
              $content = $content -replace '{{IMAGE_FULL_TAG}}', $env:IMAGE_FULL_TAG
              $content = $content -replace '{{APP_ROUTE}}', $env:APP_ROUTE
              $content = $content -replace '{{SERVICE_PORT}}', "$($env:SERVICE_PORT)"
              $content = $content -replace '{{CONTAINER_PORT}}', "$($env:CONTAINER_PORT)"

              $outputFile = Join-Path $env:PROCESSED_K8S_DIR $filename
              $content | Set-Content -Path $outputFile
          }

      - name: Apply Kubernetes Manifests (Locally)
        shell: powershell
        run: |
          # 1. Applique le namespace en premier (si namespace.yaml existe)
          kubectl apply -f ${{ env.PROCESSED_K8S_DIR }}\namespace.yaml -ErrorAction SilentlyContinue

          # 2. Applique tous les autres manifestes (Deployment, Service, Ingress, etc.)
          kubectl apply -f ${{ env.PROCESSED_K8S_DIR }}\

          # 3. Applique le monitoring en dernier
          Get-ChildItem -Path $env:PROCESSED_K8S_DIR -Filter "*-monitor.yaml" -ErrorAction SilentlyContinue | ForEach-Object {
              kubectl apply -f $_.FullName
          }
          
      - name: Upload K8s manifests artifacts
        uses: actions/upload-artifact@v4
        with:
          name: k8s-artifacts
          path: ${{env.PROCESSED_K8S_DIR}}
          retention-days: 2

  # --- Jobs de notification (Chemins corrig√©s pour GitHub) ---

  # notify_success:
  #   needs: [build, deploy]
  #   if: success() && always()
  #   uses: ./.github/workflows/notifications.yml # CORRIG√â : utilise .github
  #   with:
  #     status: success
  #     repository: ${{ github.repository }}
  #     branch: ${{ github.ref }}
  #     run_id: ${{ github.run_id }}
  #     actor: ${{ github.actor }}
  #   secrets:
  #     EMAIL_NOTIFICATION_TOKEN: ${{ secrets.EMAIL_NOTIFICATION_TOKEN }}

  # notify_failure:
  #   needs: [build, deploy]
  #   if: failure() && always()
  #   uses: ./.github/workflows/notifications.yml # CORRIG√â : utilise .github
  #   with:
  #     status: failure
  #     repository: ${{ github.repository }}
  #     branch: ${{ github.ref }}
  #     run_id: ${{ github.run_id }}
  #     actor: ${{ github.actor }}
  #   secrets:
  #     EMAIL_NOTIFICATION_TOKEN: ${{ secrets.EMAIL_NOTIFICATION_TOKEN }}
